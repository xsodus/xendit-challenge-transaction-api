/*
 * CyberSource Merged Spec
 * All CyberSource API specs merged together. These are available at https://developer.cybersource.com/api/reference/api-reference.html
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.math.BigDecimal;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;

/**
 * ECheckConfigUnderwriting
 */
@JsonPropertyOrder({
  ECheckConfigUnderwriting.JSON_PROPERTY_STANDARD_ENTRY_CLASS_CODES,
  ECheckConfigUnderwriting.JSON_PROPERTY_ENABLE_HOLD,
  ECheckConfigUnderwriting.JSON_PROPERTY_MONTHLY_TOTAL_TRANSACTION_AMOUNT_LIMIT,
  ECheckConfigUnderwriting.JSON_PROPERTY_HOLDING_DAYS,
  ECheckConfigUnderwriting.JSON_PROPERTY_ENABLE_CREDITS,
  ECheckConfigUnderwriting.JSON_PROPERTY_TRANSACTION_AMOUNT_LIMIT,
  ECheckConfigUnderwriting.JSON_PROPERTY_RISK_RESERVE_METHOD,
  ECheckConfigUnderwriting.JSON_PROPERTY_RISK_RESERVE_RATE,
  ECheckConfigUnderwriting.JSON_PROPERTY_RISK_RESERVE_TARGET_AMOUNT,
  ECheckConfigUnderwriting.JSON_PROPERTY_SOLUTION_ORGANIZATION_ID
})
@JsonTypeName("ECheckConfig_underwriting")
//@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-11-09T19:17:21.826843+07:00[Asia/Bangkok]", comments = "Generator version: 7.9.0")
public class ECheckConfigUnderwriting {
  public static final String JSON_PROPERTY_STANDARD_ENTRY_CLASS_CODES = "standardEntryClassCodes";
  private String standardEntryClassCodes = "CCD,PPD,TEL,WEB";

  public static final String JSON_PROPERTY_ENABLE_HOLD = "enableHold";
  private Boolean enableHold = true;

  public static final String JSON_PROPERTY_MONTHLY_TOTAL_TRANSACTION_AMOUNT_LIMIT = "monthlyTotalTransactionAmountLimit";
  private BigDecimal monthlyTotalTransactionAmountLimit;

  public static final String JSON_PROPERTY_HOLDING_DAYS = "holdingDays";
  private BigDecimal holdingDays;

  public static final String JSON_PROPERTY_ENABLE_CREDITS = "enableCredits";
  private Boolean enableCredits;

  public static final String JSON_PROPERTY_TRANSACTION_AMOUNT_LIMIT = "transactionAmountLimit";
  private BigDecimal transactionAmountLimit;

  public static final String JSON_PROPERTY_RISK_RESERVE_METHOD = "riskReserveMethod";
  private String riskReserveMethod;

  public static final String JSON_PROPERTY_RISK_RESERVE_RATE = "riskReserveRate";
  private BigDecimal riskReserveRate;

  public static final String JSON_PROPERTY_RISK_RESERVE_TARGET_AMOUNT = "riskReserveTargetAmount";
  private BigDecimal riskReserveTargetAmount;

  public static final String JSON_PROPERTY_SOLUTION_ORGANIZATION_ID = "solutionOrganizationId";
  private String solutionOrganizationId;

  public ECheckConfigUnderwriting() {
  }

  public ECheckConfigUnderwriting standardEntryClassCodes(String standardEntryClassCodes) {
    
    this.standardEntryClassCodes = standardEntryClassCodes;
    return this;
  }

  /**
   * Mandatory  Free-text (csv)  Possible values (combination):  CCD — Cash Concentration or Disbursement, or CCD, is a charge or refund against a business checking account. One-time or recurring CCD transactions are fund transfers to or from a corporate entity. A standing authorization is required for recurring transactions. PPD — Prearranged Payment and Deposit Entry, or PPD, is a charge or refund against a customer&#39;s checking or savings account. PPD entries can only be originated when payment and deposit terms between the merchant and the customer are prearranged. A written authorization from the customer is required for one-time transactions and a written standing authorization is required for recurring transactions. TEL — Telephone-Initiated Entry, or TEL, is a one-time charge against a customer&#39;s checking or savings account. TEL transactions can only be originated when a business relationship between the merchant and the customer already exists; or if a relationship does not exist, then only when the customer initiates the telephone call to the merchant. Payment authorization is obtained from the customer by telephone. WEB — Internet-Initiated Entry or WEB is a charge against a customer&#39;s checking or savings account. One-time or recurring WEB transactions are originated through the Internet. Payment authorization is also obtained from the customer through the Internet. 
   * @return standardEntryClassCodes
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_STANDARD_ENTRY_CLASS_CODES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getStandardEntryClassCodes() {
    return standardEntryClassCodes;
  }


  @JsonProperty(JSON_PROPERTY_STANDARD_ENTRY_CLASS_CODES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setStandardEntryClassCodes(String standardEntryClassCodes) {
    this.standardEntryClassCodes = standardEntryClassCodes;
  }

  public ECheckConfigUnderwriting enableHold(Boolean enableHold) {
    
    this.enableHold = enableHold;
    return this;
  }

  /**
   * Mandatory  Determines whether CYBS has placed the merchant on a funding hold This will often be set to True for new merchants until the risk team has completed additional verification of their first transaction. It will be switched to \&quot;false\&quot; once underwriting review is completed and we are ready to start funding the merchant. 
   * @return enableHold
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_ENABLE_HOLD)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Boolean getEnableHold() {
    return enableHold;
  }


  @JsonProperty(JSON_PROPERTY_ENABLE_HOLD)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setEnableHold(Boolean enableHold) {
    this.enableHold = enableHold;
  }

  public ECheckConfigUnderwriting monthlyTotalTransactionAmountLimit(BigDecimal monthlyTotalTransactionAmountLimit) {
    
    this.monthlyTotalTransactionAmountLimit = monthlyTotalTransactionAmountLimit;
    return this;
  }

  /**
   * Mandatory  Monthly Maximum total Transaction Amount 12 digit including decimal 
   * @return monthlyTotalTransactionAmountLimit
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_MONTHLY_TOTAL_TRANSACTION_AMOUNT_LIMIT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public BigDecimal getMonthlyTotalTransactionAmountLimit() {
    return monthlyTotalTransactionAmountLimit;
  }


  @JsonProperty(JSON_PROPERTY_MONTHLY_TOTAL_TRANSACTION_AMOUNT_LIMIT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setMonthlyTotalTransactionAmountLimit(BigDecimal monthlyTotalTransactionAmountLimit) {
    this.monthlyTotalTransactionAmountLimit = monthlyTotalTransactionAmountLimit;
  }

  public ECheckConfigUnderwriting holdingDays(BigDecimal holdingDays) {
    
    this.holdingDays = holdingDays;
    return this;
  }

  /**
   * Mandatory  Funds Hold Days (Number of days funds will be held before it will be deposited into merchant account) 3 digits 
   * @return holdingDays
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_HOLDING_DAYS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public BigDecimal getHoldingDays() {
    return holdingDays;
  }


  @JsonProperty(JSON_PROPERTY_HOLDING_DAYS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setHoldingDays(BigDecimal holdingDays) {
    this.holdingDays = holdingDays;
  }

  public ECheckConfigUnderwriting enableCredits(Boolean enableCredits) {
    
    this.enableCredits = enableCredits;
    return this;
  }

  /**
   * Optional  Allow Credits (True/False) 
   * @return enableCredits
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ENABLE_CREDITS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getEnableCredits() {
    return enableCredits;
  }


  @JsonProperty(JSON_PROPERTY_ENABLE_CREDITS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setEnableCredits(Boolean enableCredits) {
    this.enableCredits = enableCredits;
  }

  public ECheckConfigUnderwriting transactionAmountLimit(BigDecimal transactionAmountLimit) {
    
    this.transactionAmountLimit = transactionAmountLimit;
    return this;
  }

  /**
   * Mandatory  Maximum total Transaction Amount This is a per transaction limit. For example, the merchant is limited to processing transactions under $100 12 digits (including decimal - USD only) 
   * @return transactionAmountLimit
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_TRANSACTION_AMOUNT_LIMIT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public BigDecimal getTransactionAmountLimit() {
    return transactionAmountLimit;
  }


  @JsonProperty(JSON_PROPERTY_TRANSACTION_AMOUNT_LIMIT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setTransactionAmountLimit(BigDecimal transactionAmountLimit) {
    this.transactionAmountLimit = transactionAmountLimit;
  }

  public ECheckConfigUnderwriting riskReserveMethod(String riskReserveMethod) {
    
    this.riskReserveMethod = riskReserveMethod;
    return this;
  }

  /**
   * Mandatory Reserve Method  Possible value: - fixed - none Most merchants do not have a reserve attached to their account so the default value would be \&quot;none.\&quot;   For a Fixed Reserve, the reserve balance is established by either, (1) a receipt of a lump sum deposit from a merchant, or (2) withholding funds at a Reserve Rate established for the account from each batch settlement until the reserve balance is equal to a set Reserve Target. A Fixed Reserve may also be established by a combination of lump sum deposit and withholding of settlement funds.  A Rolling Reserve balance is established by withholding from a merchant&#39;s available settlement funds at a Reserve Rate (percentage) and no Reserve Target is specified. Rather, each amount withheld is retained for a specified number of Reserve Holding Days and then released back to the merchant. 
   * @return riskReserveMethod
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_RISK_RESERVE_METHOD)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getRiskReserveMethod() {
    return riskReserveMethod;
  }


  @JsonProperty(JSON_PROPERTY_RISK_RESERVE_METHOD)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setRiskReserveMethod(String riskReserveMethod) {
    this.riskReserveMethod = riskReserveMethod;
  }

  public ECheckConfigUnderwriting riskReserveRate(BigDecimal riskReserveRate) {
    
    this.riskReserveRate = riskReserveRate;
    return this;
  }

  /**
   * Mandatory  Reserve Rate (% of TPV)&#x3D;&gt; Relevant for Rolling Reserve and Fixed Reserve The percentage rate at which risk funds are withheld from each eCheck.Net batch settlement. 
   * @return riskReserveRate
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_RISK_RESERVE_RATE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public BigDecimal getRiskReserveRate() {
    return riskReserveRate;
  }


  @JsonProperty(JSON_PROPERTY_RISK_RESERVE_RATE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setRiskReserveRate(BigDecimal riskReserveRate) {
    this.riskReserveRate = riskReserveRate;
  }

  public ECheckConfigUnderwriting riskReserveTargetAmount(BigDecimal riskReserveTargetAmount) {
    
    this.riskReserveTargetAmount = riskReserveTargetAmount;
    return this;
  }

  /**
   * Mandatory  Reserve Target (fixed $ amount)&#x3D;&gt; Relevant for Fixed Reserve ONLY  The maximum dollar amount that can be held in Risk Reserve for a fixed reserve. Once risk withholdings reach the Reserve Target established for the eCheck.Net account, a portion of available funds will be deposited to the merchant&#39;s bank account 12 digit including decimal 
   * @return riskReserveTargetAmount
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_RISK_RESERVE_TARGET_AMOUNT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public BigDecimal getRiskReserveTargetAmount() {
    return riskReserveTargetAmount;
  }


  @JsonProperty(JSON_PROPERTY_RISK_RESERVE_TARGET_AMOUNT)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setRiskReserveTargetAmount(BigDecimal riskReserveTargetAmount) {
    this.riskReserveTargetAmount = riskReserveTargetAmount;
  }

  public ECheckConfigUnderwriting solutionOrganizationId(String solutionOrganizationId) {
    
    this.solutionOrganizationId = solutionOrganizationId;
    return this;
  }

  /**
   * Solution organization id
   * @return solutionOrganizationId
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_SOLUTION_ORGANIZATION_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getSolutionOrganizationId() {
    return solutionOrganizationId;
  }


  @JsonProperty(JSON_PROPERTY_SOLUTION_ORGANIZATION_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSolutionOrganizationId(String solutionOrganizationId) {
    this.solutionOrganizationId = solutionOrganizationId;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ECheckConfigUnderwriting echeckConfigUnderwriting = (ECheckConfigUnderwriting) o;
    return Objects.equals(this.standardEntryClassCodes, echeckConfigUnderwriting.standardEntryClassCodes) &&
        Objects.equals(this.enableHold, echeckConfigUnderwriting.enableHold) &&
        Objects.equals(this.monthlyTotalTransactionAmountLimit, echeckConfigUnderwriting.monthlyTotalTransactionAmountLimit) &&
        Objects.equals(this.holdingDays, echeckConfigUnderwriting.holdingDays) &&
        Objects.equals(this.enableCredits, echeckConfigUnderwriting.enableCredits) &&
        Objects.equals(this.transactionAmountLimit, echeckConfigUnderwriting.transactionAmountLimit) &&
        Objects.equals(this.riskReserveMethod, echeckConfigUnderwriting.riskReserveMethod) &&
        Objects.equals(this.riskReserveRate, echeckConfigUnderwriting.riskReserveRate) &&
        Objects.equals(this.riskReserveTargetAmount, echeckConfigUnderwriting.riskReserveTargetAmount) &&
        Objects.equals(this.solutionOrganizationId, echeckConfigUnderwriting.solutionOrganizationId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(standardEntryClassCodes, enableHold, monthlyTotalTransactionAmountLimit, holdingDays, enableCredits, transactionAmountLimit, riskReserveMethod, riskReserveRate, riskReserveTargetAmount, solutionOrganizationId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ECheckConfigUnderwriting {\n");
    sb.append("    standardEntryClassCodes: ").append(toIndentedString(standardEntryClassCodes)).append("\n");
    sb.append("    enableHold: ").append(toIndentedString(enableHold)).append("\n");
    sb.append("    monthlyTotalTransactionAmountLimit: ").append(toIndentedString(monthlyTotalTransactionAmountLimit)).append("\n");
    sb.append("    holdingDays: ").append(toIndentedString(holdingDays)).append("\n");
    sb.append("    enableCredits: ").append(toIndentedString(enableCredits)).append("\n");
    sb.append("    transactionAmountLimit: ").append(toIndentedString(transactionAmountLimit)).append("\n");
    sb.append("    riskReserveMethod: ").append(toIndentedString(riskReserveMethod)).append("\n");
    sb.append("    riskReserveRate: ").append(toIndentedString(riskReserveRate)).append("\n");
    sb.append("    riskReserveTargetAmount: ").append(toIndentedString(riskReserveTargetAmount)).append("\n");
    sb.append("    solutionOrganizationId: ").append(toIndentedString(solutionOrganizationId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

