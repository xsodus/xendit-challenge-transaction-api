/*
 * CyberSource Merged Spec
 * All CyberSource API specs merged together. These are available at https://developer.cybersource.com/api/reference/api-reference.html
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;

/**
 * Retry policy for the individual webhooks that are a part of your subscription. If a message fails to deliver, it will execute through this retry policy.  Automatic suspend and resume:  If you experience downtime and have &#x60;deactivateFlag &#x3D; true&#x60; any new messages will be held in a \&quot;SUSPENDED\&quot; status. When your healthCheckUrl returns healthy again, the subscription will automatically be re-enabled and your messages will be sent. We will ping your healthCheckUrl routinely using a POST call with an empty payload to check availability. If your endpoint returns an unhealthy status of !&#x3D; 200, we will check the healthCheckUrl at a more frequent rate until it is healthy again.  If you experience downtime and have &#x60;deactivateFlag &#x3D; false&#x60; and your message exhausts all retry attempts the message will go to a \&quot;FAILED\&quot; status. Support will be notified and will reach out to suggest you execute the \&quot;REPLAY\&quot; endpoint at a later date when your server is healthy.   Reference the below values for formulas and calculations related to the frequency of retries depending on algorithm and configuration. 
 */
@JsonPropertyOrder({
  GetWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy.JSON_PROPERTY_ALGORITHM,
  GetWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy.JSON_PROPERTY_FIRST_RETRY,
  GetWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy.JSON_PROPERTY_INTERVAL,
  GetWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy.JSON_PROPERTY_NUMBER_OF_RETRIES,
  GetWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy.JSON_PROPERTY_DEACTIVATE_FLAG,
  GetWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy.JSON_PROPERTY_REPEAT_SEQUENCE_COUNT,
  GetWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy.JSON_PROPERTY_REPEAT_SEQUENCE_WAIT_TIME,
  GetWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy.JSON_PROPERTY_ADDITIONAL_ATTRIBUTES
})
@JsonTypeName("getWebhookSubscriptionsByOrg_200_response_inner_retryPolicy")
//@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-11-09T19:17:21.826843+07:00[Asia/Bangkok]", comments = "Generator version: 7.9.0")
public class GetWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy {
  public static final String JSON_PROPERTY_ALGORITHM = "algorithm";
  private String algorithm;

  public static final String JSON_PROPERTY_FIRST_RETRY = "firstRetry";
  private Integer firstRetry;

  public static final String JSON_PROPERTY_INTERVAL = "interval";
  private Integer interval;

  public static final String JSON_PROPERTY_NUMBER_OF_RETRIES = "numberOfRetries";
  private Integer numberOfRetries;

  public static final String JSON_PROPERTY_DEACTIVATE_FLAG = "deactivateFlag";
  private String deactivateFlag;

  public static final String JSON_PROPERTY_REPEAT_SEQUENCE_COUNT = "repeatSequenceCount";
  private Integer repeatSequenceCount;

  public static final String JSON_PROPERTY_REPEAT_SEQUENCE_WAIT_TIME = "repeatSequenceWaitTime";
  private Integer repeatSequenceWaitTime;

  public static final String JSON_PROPERTY_ADDITIONAL_ATTRIBUTES = "additionalAttributes";
  private List<Map<String, String>> additionalAttributes = new ArrayList<>();

  public GetWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy() {
  }

  public GetWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy algorithm(String algorithm) {
    
    this.algorithm = algorithm;
    return this;
  }

  /**
   * This is used to calculate the Retry Sequence.  Sample calculations using firstRetry&#x3D;10, interval&#x3D;30, maxNumberOfRetries&#x3D;3 Arithmetic &#x3D; a+r(n-1) Retry 1 - 10 minutes Retry 2 - 10+30x1 &#x3D; 40 minutes Retry 3 - 10+30x2 &#x3D; 70 minutes  Geometric &#x3D; ar^(n-1) Retry 1 - 10 minutes Retry 2 - 10x30^1 &#x3D; 300 minutes Retry 3 - 10x30^2 &#x3D; 9,000 minutes 
   * @return algorithm
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ALGORITHM)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getAlgorithm() {
    return algorithm;
  }


  @JsonProperty(JSON_PROPERTY_ALGORITHM)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAlgorithm(String algorithm) {
    this.algorithm = algorithm;
  }

  public GetWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy firstRetry(Integer firstRetry) {
    
    this.firstRetry = firstRetry;
    return this;
  }

  /**
   * When to initiate first retry, after the initial call failed. (in mins).
   * @return firstRetry
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_FIRST_RETRY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getFirstRetry() {
    return firstRetry;
  }


  @JsonProperty(JSON_PROPERTY_FIRST_RETRY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setFirstRetry(Integer firstRetry) {
    this.firstRetry = firstRetry;
  }

  public GetWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy interval(Integer interval) {
    
    this.interval = interval;
    return this;
  }

  /**
   * The interval between retries (in mins).
   * @return interval
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_INTERVAL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getInterval() {
    return interval;
  }


  @JsonProperty(JSON_PROPERTY_INTERVAL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setInterval(Integer interval) {
    this.interval = interval;
  }

  public GetWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy numberOfRetries(Integer numberOfRetries) {
    
    this.numberOfRetries = numberOfRetries;
    return this;
  }

  /**
   * The number of retries per sequence.
   * @return numberOfRetries
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_NUMBER_OF_RETRIES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getNumberOfRetries() {
    return numberOfRetries;
  }


  @JsonProperty(JSON_PROPERTY_NUMBER_OF_RETRIES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setNumberOfRetries(Integer numberOfRetries) {
    this.numberOfRetries = numberOfRetries;
  }

  public GetWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy deactivateFlag(String deactivateFlag) {
    
    this.deactivateFlag = deactivateFlag;
    return this;
  }

  /**
   * Deactivate the subscription if your retries fail to deliver.  If this is set to &#x60;true&#x60;, the automatic suspend and resume feature will occur. This would prevent new webhooks from attempting to deliver and to queue up until your healthCheckUrl returns 200 again, then all messages will be sent.  If this is set to &#x60;false&#x60;, new individual messages will continue to retry and exhaust all failures, but the subscription will stay active. 
   * @return deactivateFlag
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_DEACTIVATE_FLAG)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getDeactivateFlag() {
    return deactivateFlag;
  }


  @JsonProperty(JSON_PROPERTY_DEACTIVATE_FLAG)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDeactivateFlag(String deactivateFlag) {
    this.deactivateFlag = deactivateFlag;
  }

  public GetWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy repeatSequenceCount(Integer repeatSequenceCount) {
    
    this.repeatSequenceCount = repeatSequenceCount;
    return this;
  }

  /**
   * The number of times to repeat the complete retry sequence. 0 &#x3D;&gt; don&#39;t repeat the retry sequence 1 &#x3D;&gt; repeat the retry sequence once (R1, R2, R3)+ (R1, R2, R3) 2 &#x3D;&gt; repeat the retry sequence twice (R1, R2, R3) + (R1, R2, R3) + (R1, R2, R3) 
   * @return repeatSequenceCount
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_REPEAT_SEQUENCE_COUNT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getRepeatSequenceCount() {
    return repeatSequenceCount;
  }


  @JsonProperty(JSON_PROPERTY_REPEAT_SEQUENCE_COUNT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRepeatSequenceCount(Integer repeatSequenceCount) {
    this.repeatSequenceCount = repeatSequenceCount;
  }

  public GetWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy repeatSequenceWaitTime(Integer repeatSequenceWaitTime) {
    
    this.repeatSequenceWaitTime = repeatSequenceWaitTime;
    return this;
  }

  /**
   * The time to wait to before repeating the complete retry sequence. Amount of time to wait between each sequence. Sample calculation using repeatSequenceWaitTime&#x3D;10 (R1, R2, R3) + (10) + (R1, R2, R3) + (10) + (R1, R2, R3) 
   * @return repeatSequenceWaitTime
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_REPEAT_SEQUENCE_WAIT_TIME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getRepeatSequenceWaitTime() {
    return repeatSequenceWaitTime;
  }


  @JsonProperty(JSON_PROPERTY_REPEAT_SEQUENCE_WAIT_TIME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRepeatSequenceWaitTime(Integer repeatSequenceWaitTime) {
    this.repeatSequenceWaitTime = repeatSequenceWaitTime;
  }

  public GetWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy additionalAttributes(List<Map<String, String>> additionalAttributes) {
    
    this.additionalAttributes = additionalAttributes;
    return this;
  }

  public GetWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy addAdditionalAttributesItem(Map<String, String> additionalAttributesItem) {
    if (this.additionalAttributes == null) {
      this.additionalAttributes = new ArrayList<>();
    }
    this.additionalAttributes.add(additionalAttributesItem);
    return this;
  }

  /**
   * Additional data, if any.
   * @return additionalAttributes
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ADDITIONAL_ATTRIBUTES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<Map<String, String>> getAdditionalAttributes() {
    return additionalAttributes;
  }


  @JsonProperty(JSON_PROPERTY_ADDITIONAL_ATTRIBUTES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAdditionalAttributes(List<Map<String, String>> additionalAttributes) {
    this.additionalAttributes = additionalAttributes;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GetWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy getWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy = (GetWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy) o;
    return Objects.equals(this.algorithm, getWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy.algorithm) &&
        Objects.equals(this.firstRetry, getWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy.firstRetry) &&
        Objects.equals(this.interval, getWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy.interval) &&
        Objects.equals(this.numberOfRetries, getWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy.numberOfRetries) &&
        Objects.equals(this.deactivateFlag, getWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy.deactivateFlag) &&
        Objects.equals(this.repeatSequenceCount, getWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy.repeatSequenceCount) &&
        Objects.equals(this.repeatSequenceWaitTime, getWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy.repeatSequenceWaitTime) &&
        Objects.equals(this.additionalAttributes, getWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy.additionalAttributes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(algorithm, firstRetry, interval, numberOfRetries, deactivateFlag, repeatSequenceCount, repeatSequenceWaitTime, additionalAttributes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GetWebhookSubscriptionsByOrg200ResponseInnerRetryPolicy {\n");
    sb.append("    algorithm: ").append(toIndentedString(algorithm)).append("\n");
    sb.append("    firstRetry: ").append(toIndentedString(firstRetry)).append("\n");
    sb.append("    interval: ").append(toIndentedString(interval)).append("\n");
    sb.append("    numberOfRetries: ").append(toIndentedString(numberOfRetries)).append("\n");
    sb.append("    deactivateFlag: ").append(toIndentedString(deactivateFlag)).append("\n");
    sb.append("    repeatSequenceCount: ").append(toIndentedString(repeatSequenceCount)).append("\n");
    sb.append("    repeatSequenceWaitTime: ").append(toIndentedString(repeatSequenceWaitTime)).append("\n");
    sb.append("    additionalAttributes: ").append(toIndentedString(additionalAttributes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

