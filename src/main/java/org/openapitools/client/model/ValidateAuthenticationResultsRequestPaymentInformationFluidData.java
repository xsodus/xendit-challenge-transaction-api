/*
 * CyberSource Merged Spec
 * All CyberSource API specs merged together. These are available at https://developer.cybersource.com/api/reference/api-reference.html
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;

/**
 * ValidateAuthenticationResultsRequestPaymentInformationFluidData
 */
@JsonPropertyOrder({
  ValidateAuthenticationResultsRequestPaymentInformationFluidData.JSON_PROPERTY_VALUE,
  ValidateAuthenticationResultsRequestPaymentInformationFluidData.JSON_PROPERTY_KEY_SERIAL_NUMBER,
  ValidateAuthenticationResultsRequestPaymentInformationFluidData.JSON_PROPERTY_DESCRIPTOR,
  ValidateAuthenticationResultsRequestPaymentInformationFluidData.JSON_PROPERTY_ENCODING
})
@JsonTypeName("validateAuthenticationResults_request_paymentInformation_fluidData")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-11-09T18:32:10.370382+07:00[Asia/Bangkok]", comments = "Generator version: 7.9.0")
public class ValidateAuthenticationResultsRequestPaymentInformationFluidData {
  public static final String JSON_PROPERTY_VALUE = "value";
  private String value;

  public static final String JSON_PROPERTY_KEY_SERIAL_NUMBER = "keySerialNumber";
  private String keySerialNumber;

  public static final String JSON_PROPERTY_DESCRIPTOR = "descriptor";
  private String descriptor;

  public static final String JSON_PROPERTY_ENCODING = "encoding";
  private String encoding;

  public ValidateAuthenticationResultsRequestPaymentInformationFluidData() {
  }

  public ValidateAuthenticationResultsRequestPaymentInformationFluidData value(String value) {
    
    this.value = value;
    return this;
  }

  /**
   * Represents the encrypted payment data BLOB. The entry for this field is dependent on the payment solution used by the merchant. Used by Authorization and Standalone Credits. Required for authorizations and standalone credits that use a Cybersource suppored Point-to-Point encryption method. Card Present processing This field represents the encrypted payment data generated by the payment terminal/device. 
   * @return value
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_VALUE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getValue() {
    return value;
  }


  @JsonProperty(JSON_PROPERTY_VALUE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setValue(String value) {
    this.value = value;
  }

  public ValidateAuthenticationResultsRequestPaymentInformationFluidData keySerialNumber(String keySerialNumber) {
    
    this.keySerialNumber = keySerialNumber;
    return this;
  }

  /**
   * The encoded or encrypted value that a payment solution returns for an authorization request. For details about the valid values for a key, see [Creating an Online Authorization](https://developer.cybersource.com/api/developer-guides/dita-payments/CreatingOnlineAuth.html) 
   * @return keySerialNumber
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_KEY_SERIAL_NUMBER)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getKeySerialNumber() {
    return keySerialNumber;
  }


  @JsonProperty(JSON_PROPERTY_KEY_SERIAL_NUMBER)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setKeySerialNumber(String keySerialNumber) {
    this.keySerialNumber = keySerialNumber;
  }

  public ValidateAuthenticationResultsRequestPaymentInformationFluidData descriptor(String descriptor) {
    
    this.descriptor = descriptor;
    return this;
  }

  /**
   * The identifier for a payment solution, which is sending the encrypted payment data for decryption. Valid values: Samsung Pay: RklEPUNPTU1PTi5TQU1TVU5HLklOQVBQLlBBWU1FTlQ&#x3D; Note: For other payment solutions, the value may be specific to the terminal or device initiatinf the payment. For example, the descriptor for a Bluefin payment encryption would be a device-generated descriptor. Used by Authorization and Standalone Credits. Required for authorizations and standalone credits.  Card Present processing: Format of the encrypted payment data. The value for Bluefin PCI P2PE is &#x60;Ymx1ZWZpbg&#x3D;&#x3D;&#x60;. paymentInformation.fluidData.encoding must be &#x60;Base64&#x60;. The value for Cybersource P2PE decryption depends on the encoding method used and identified in encoding field. If paymentInformation.fluidData.encoding is &#x60;Base64&#x60;, the value is: &#x60;RklEPUVNVi5QQVlNRU5ULkFQSQ&#x3D;&#x3D;&#x60; If paymentInformation.fluidData.encoding is &#x60;HEX&#x60;, the value is: &#x60;4649443D454D562E5041594D454E542E41504&#x60; 
   * @return descriptor
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_DESCRIPTOR)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getDescriptor() {
    return descriptor;
  }


  @JsonProperty(JSON_PROPERTY_DESCRIPTOR)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDescriptor(String descriptor) {
    this.descriptor = descriptor;
  }

  public ValidateAuthenticationResultsRequestPaymentInformationFluidData encoding(String encoding) {
    
    this.encoding = encoding;
    return this;
  }

  /**
   * Encoding method used to encrypt the payment data. Valid values: &#x60;Base64&#x60;, &#x60;HEX&#x60; If no value is provided, &#x60;Base64&#x60; is taken as the default value. And the &#x60;Base64&#x60; descriptor is used for paymentInformation.fluidData.encoding 
   * @return encoding
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ENCODING)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getEncoding() {
    return encoding;
  }


  @JsonProperty(JSON_PROPERTY_ENCODING)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setEncoding(String encoding) {
    this.encoding = encoding;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ValidateAuthenticationResultsRequestPaymentInformationFluidData validateAuthenticationResultsRequestPaymentInformationFluidData = (ValidateAuthenticationResultsRequestPaymentInformationFluidData) o;
    return Objects.equals(this.value, validateAuthenticationResultsRequestPaymentInformationFluidData.value) &&
        Objects.equals(this.keySerialNumber, validateAuthenticationResultsRequestPaymentInformationFluidData.keySerialNumber) &&
        Objects.equals(this.descriptor, validateAuthenticationResultsRequestPaymentInformationFluidData.descriptor) &&
        Objects.equals(this.encoding, validateAuthenticationResultsRequestPaymentInformationFluidData.encoding);
  }

  @Override
  public int hashCode() {
    return Objects.hash(value, keySerialNumber, descriptor, encoding);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ValidateAuthenticationResultsRequestPaymentInformationFluidData {\n");
    sb.append("    value: ").append(toIndentedString(value)).append("\n");
    sb.append("    keySerialNumber: ").append(toIndentedString(keySerialNumber)).append("\n");
    sb.append("    descriptor: ").append(toIndentedString(descriptor)).append("\n");
    sb.append("    encoding: ").append(toIndentedString(encoding)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

